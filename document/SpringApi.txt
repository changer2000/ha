org.springframework.web：
	WebApplicationInitializer <-----|
		 <servlet>
		   <servlet-name>dispatcher</servlet-name>
		   <servlet-class>
			 org.springframework.web.servlet.DispatcherServlet
		   </servlet-class>
		   <init-param>
			 <param-name>contextConfigLocation</param-name>
			 <param-value>/WEB-INF/spring/dispatcher-config.xml</param-value>
		   </init-param>
		   <load-on-startup>1</load-on-startup>
		 </servlet>

		 <servlet-mapping>
		   <servlet-name>dispatcher</servlet-name>
		   <url-pattern>/</url-pattern>
		 </servlet-mapping>
	
		 ===========================================================================================
		 public class MyWebAppInitializer implements WebApplicationInitializer {

			@Override
			public void onStartup(ServletContext container) {
			  XmlWebApplicationContext appContext = new XmlWebApplicationContext();
			  appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

			  ServletRegistration.Dynamic dispatcher =
				container.addServlet("dispatcher", new DispatcherServlet(appContext));
			  dispatcher.setLoadOnStartup(1);
			  dispatcher.addMapping("/");
			}

		 }
		
		 ===========================================================================================
		@Override
		public void onStartup(ServletContext container) {
		  // Create the 'root' Spring application context
		  AnnotationConfigWebApplicationContext rootContext =
			new AnnotationConfigWebApplicationContext();
		  rootContext.register(AppConfig.class);

		  // Manage the lifecycle of the root application context
		  container.addListener(new ContextLoaderListener(rootContext));

		  // Create the dispatcher servlet's Spring application context
		  AnnotationConfigWebApplicationContext dispatcherContext =
			new AnnotationConfigWebApplicationContext();
		  dispatcherContext.register(DispatcherConfig.class);

		  // Register and map the dispatcher servlet
		  ServletRegistration.Dynamic dispatcher =
			container.addServlet("dispatcher", new DispatcherServlet(dispatcherContext));
		  dispatcher.setLoadOnStartup(1);
		  dispatcher.addMapping("/");
		}

				 
	
	SpringServletContainerInitializer：猜测这个是spring web启动的起点

org.springframework.web.accept

org.springframework.web.bind
	EscapedErrors:有很多rejectValue(......)方法。Errors wrapper that adds automatic HTML escaping to the wrapped instance, for convenient usage in HTML views. Can be retrieved easily via RequestContext's getErrors method. 
	ServletRequestDataBinder
		例子：
			 MyBean myBean = new MyBean();
			 // apply binder to custom target object
			 ServletRequestDataBinder binder = new ServletRequestDataBinder(myBean);
			 // register custom editors, if desired
			 binder.registerCustomEditor(...);
			 // trigger actual binding of request parameters
			 binder.bind(request);
			 // optionally evaluate binding errors
			 Errors errors = binder.getErrors();
	ServletRequestParameterPropertyValues
	ServletRequestUtils，里面有很多从request里得到值的方法
	WebDataBinder（子类：PortletRequestDataBinder, ServletRequestDataBinder, WebRequestDataBinder）

org.springframework.web.bind.annotation.support
	HandlerMethodInvoker
	HandlerMethodResolver
	
	
org.springframework.web.bind.annotation：	里面定义了很多annotation，可以在很多地方使用
	ExceptionHandler：被它声明的方法，可以捕获特定的exception
	MatrixVariable
	ModelAttribute
	RequestHeader
	RequestMapping
	RequestBody: 用于没有上传文件的form
	RequestPart：用于有上传文件的form。@RequestParam annotation can also be used to associate the part of a "multipart/form-data" request with a method argument supporting the same method argument types. The main difference is that when the method argument is not a String, @RequestParam relies on type conversion via a registered Converter or PropertyEditor while @RequestPart relies on HttpMessageConverters taking into consideration the 'Content-Type' header of the request part. @RequestParam is likely to be used with name-value form fields while @RequestPart is likely to be used with parts containing more complex content (e.g. JSON, XML).
	ResponseStatus
	SessionStatus.setComplete()
	
org.springframework.web.bind.annotation.support
	HandlerMethodInvoker:Used by AnnotationMethodHandlerAdapter and AnnotationMethodHandlerAdapter.   <====== 是个很重要的类
		有很多类似resolveRequestBody() / resolveCookieValue()这样的方法
	HandlerMethodResolver:Support class for resolving web method annotations in a handler type. Processes @RequestMapping, @InitBinder, @ModelAttribute and @SessionAttributes. 
		Used by AnnotationMethodHandlerAdapter and AnnotationMethodHandlerAdapter.

org.springframework.web.bind.support
    SessionAttributeStore
    SessionStatus
*** WebArgumentResolver: 可以处理controller中具体方法的某个参数，非常有用的东东
    WebBindingInitializer: Callback interface for initializing a WebDataBinder for performing data binding in the context of a specific web request.
		initBinder(WebDataBinder binder, WebRequest request)：当request来时，对绑定的binder进行初始化
    WebDataBinderFactory
		WebDataBinder createBinder(NativeWebRequest webRequest,
                         Object target,
                         String objectName)
                           throws Exception		创建一个webDataBinder
						   
	ConfigurableWebBindingInitializer: Convenient WebBindingInitializer for declarative configuration in a Spring application context. Allows for reusing pre-configured initializers with multiple controller/handlers.
	DefaultDataBinderFactory: 
		initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest): Extension point to further initialize the created data binder instance (e.g.
	DefaultSessionAttributeStore:
		setAttributeNamePrefix
		storeAttribute(WebRequest request, String attributeName,  Object attributeValue)
		Object retrieveAttribute(WebRequest request, String attributeName)
		void cleanupAttribute(WebRequest request, String attributeName)
	SimpleSessionStatus
		isComplete()
		setComplete()
	WebRequestDataBinder: Special DataBinder to perform data binding from web request parameters to JavaBeans, including support for multipart files. 
		 MyBean myBean = new MyBean();
		 // apply binder to custom target object
		 WebRequestDataBinder binder = new WebRequestDataBinder(myBean);
		 // register custom editors, if desired
		 binder.registerCustomEditor(...);
		 // trigger actual binding of request parameters
		 binder.bind(request);
		 // optionally evaluate binding errors
		 Errors errors = binder.getErrors();
		
		public void bind(WebRequest request):
			Bind the parameters of the given request to this binder's target, also binding multipart files in case of a multipart request.
			This call can create field errors, representing basic binding errors like a required field (code "required"), or type mismatch between value and bean property (code "typeMismatch").
			Multipart files are bound via their parameter name, just like normal HTTP parameters: i.e. "uploadedFile" to an "uploadedFile" bean property, invoking a "setUploadedFile" setter method.
			The type of the target property for a multipart file can be MultipartFile, byte[], or String. The latter two receive the contents of the uploaded file; all metadata like original file name, content type, etc are lost in those cases.

			
org.springframework.web.client
	RequestCallback: Callback interface for code that operates on a ClientHttpRequest. Allows to manipulate the request headers, and write to the request body. 
		Used internally by the RestTemplate, but also useful for application code.
		
		void doWithRequest(ClientHttpRequest request) throws IOException : Gets called by RestTemplate.execute(java.lang.String, org.springframework.http.HttpMethod, org.springframework.web.client.RequestCallback, org.springframework.web.client.ResponseExtractor<T>, java.lang.Object...) with an opened ClientHttpRequest. 
			Does not need to care about closing the request or about handling errors: this will all be handled by the RestTemplate.
	
	ResponseErrorHandler: Strategy interface used by the RestTemplate to determine whether a particular response has an error or not.
	ResponseExtractor<T>: Generic callback interface used by RestTemplate's retrieval methods Implementations of this interface perform the actual work of extracting data from a ClientHttpResponse, but don't need to worry about exception handling or closing resources.
							Used internally by the RestTemplate, but also useful for application code.
		T extractData(ClientHttpResponse response) throws IOException : Extract data from the given ClientHttpResponse and return it.
	RestOperations: Interface specifying a basic set of RESTful operations. Implemented by RestTemplate. Not often used directly, but a useful option to enhance testability, as it can easily be mocked or stubbed.
		在test时候会用
	
	DefaultResponseErrorHandler： This error handler checks for the status code on the ClientHttpResponse: any code with series HttpStatus.Series.CLIENT_ERROR or HttpStatus.Series.SERVER_ERROR is considered to be an error. 
		This behavior can be changed by overriding the hasError(HttpStatus) method.
	HttpMessageConverterExtractor<T>： Response extractor that uses the given entity converters to convert the response into a type T.
		public HttpMessageConverterExtractor(Class<T> responseType,
                             List<HttpMessageConverter<?>> messageConverters): Creates a new instance of the HttpMessageConverterExtractor with the given response type and message converters. The given converters must support the response type.
		public HttpMessageConverterExtractor(Type responseType,
                             List<HttpMessageConverter<?>> messageConverters): Creates a new instance of the HttpMessageConverterExtractor with the given response type and message converters. The given converters must support the response type.
							 
***	RestTemplate extends InterceptingHttpAccessor implements RestOperations:非常有用的一个测试url的东东
		The central class for client-side HTTP access. It simplifies communication with HTTP servers, and enforces RESTful principles. It handles HTTP connections, leaving application code to provide URLs (with possible template variables) and extract results. 
		The exchange and execute methods are generalized versions of the more specific methods listed above them. They support additional, less frequently used combinations including support for requests using the HTTP PATCH method. However, note that the underlying HTTP library must also support the desired combination.
		For each of these HTTP methods, there are three corresponding Java methods in the RestTemplate. Two variant take a String URI as first argument (eg. getForObject(String, Class, Object[]), getForObject(String, Class, Map)), and are capable of substituting any URI templates in that URL using either a String variable arguments array, or a Map<String, String>. The string varargs variant expands the given template variables in order, so that
		 String result = restTemplate.getForObject("http://example.com/hotels/{hotel}/bookings/{booking}", String.class,"42",
		 "21");

		will perform a GET on http://example.com/hotels/42/bookings/21. The map variant expands the template based on variable name, and is therefore more useful when using many variables, or when a single variable is used multiple times. For example:

		 Map<String, String> vars = Collections.singletonMap("hotel", "42");
		 String result = restTemplate.getForObject("http://example.com/hotels/{hotel}/rooms/{hotel}", String.class, vars);
		will perform a GET on http://example.com/hotels/42/rooms/42. Alternatively, there are URI variant methods (getForObject(URI, Class)), which do not allow for URI templates, but allow you to reuse a single, expanded URI multiple times.

		Furthermore, the String-argument methods assume that the URL String is unencoded. This means that
		 restTemplate.getForObject("http://example.com/hotel list");
		will perform a GET on http://example.com/hotel%20list. As a result, any URL passed that is already encoded will be encoded twice (i.e. http://example.com/hotel%20list will become http://example.com/hotel%2520list). If this behavior is undesirable, use the URI-argument methods, which will not perform any URL encoding.

		Objects passed to and returned from these methods are converted to and from HTTP messages by HttpMessageConverter instances. Converters for the main mime types are registered by default, but you can also write your own converter and register it via the messageConverters bean property.
		This template uses a SimpleClientHttpRequestFactory and a DefaultResponseErrorHandler as default strategies for creating HTTP connections or handling HTTP errors, respectively. These defaults can be overridden through the requestFactory and errorHandler bean properties.
	
	HttpClientErrorException: Exception thrown when an HTTP 4xx is received.
	HttpServerErrorException: Exception thrown when an HTTP 5xx is received.
		public HttpHeaders getResponseHeaders()
		public byte[] getResponseBodyAsByteArray()
		public String getResponseBodyAsString()
	ResourceAccessException: Exception thrown when an I/O error occurs.
	RestClientException extends NestedRuntimeException: Base class for exceptions thrown by RestTemplate whenever it encounters client-side HTTP errors.
	UnknownHttpStatusCodeException: Exception thrown when an unknown (or custom) HTTP status code is received.
		getRawStatusCode(): Return the raw HTTP status code value.
		getResponseBodyAsByteArray(): Return the response body as a byte array.
		getResponseBodyAsString(): Return the response body as a string.
		getResponseHeaders(): Return the HTTP response headers.
		getStatusText(): Return the HTTP status text.

		
org.springframework.web.client.support
	RestGatewaySupport: Convenient super class for application classes that need REST access. Requires a ClientHttpRequestFactory or a RestTemplate instance to be set.


org.springframework.web.context
***	ConfigurableWebApplicationContext: 
		All Superinterfaces:
			ApplicationContext, ApplicationEventPublisher, AutoCloseable, BeanFactory, Closeable, ConfigurableApplicationContext, EnvironmentCapable, HierarchicalBeanFactory, Lifecycle, ListableBeanFactory, MessageSource, ResourceLoader, ResourcePatternResolver, WebApplicationContext 
		All Known Implementing Classes:
			AbstractRefreshableWebApplicationContext, AnnotationConfigWebApplicationContext, GenericWebApplicationContext, StaticWebApplicationContext, XmlWebApplicationContext 
	ConfigurableWebEnvironment extends ConfigurableEnvironment: Specialization of ConfigurableEnvironment allowing initialization of servlet-related PropertySource objects at the earliest moment that the ServletContext and (optionally) ServletConfig become available.
		void initPropertySources(ServletContext servletContext, ServletConfig servletConfig): Replace any stub property source instances acting as placeholders with real servlet context/config property sources using the given parameters.
***	ServletConfigAware: 非常有用的一个类，
		Interface to be implemented by any object that wishes to be notified of the ServletConfig (typically determined by the WebApplicationContext) that it runs in.
		Note: Only satisfied if actually running within a Servlet-specific WebApplicationContext. Otherwise, no ServletConfig will be set.
		void setServletConfig(ServletConfig servletConfig)： Set the ServletConfig that this object runs in.
			Invoked after population of normal bean properties but before an init callback like InitializingBean's afterPropertiesSet or a custom init-method. Invoked after ApplicationContextAware's setApplicationContext.
***	WebApplicationContext: 非常有用的一个类，
		All Superinterfaces:
			ApplicationContext, ApplicationEventPublisher, BeanFactory, EnvironmentCapable, HierarchicalBeanFactory, ListableBeanFactory, MessageSource, ResourceLoader, ResourcePatternResolver
		All Known Subinterfaces:
			ConfigurablePortletApplicationContext, ConfigurableWebApplicationContext
		All Known Implementing Classes:
			AbstractRefreshablePortletApplicationContext, AbstractRefreshableWebApplicationContext, AnnotationConfigWebApplicationContext, GenericWebApplicationContext, StaticPortletApplicationContext, StaticWebApplicationContext, XmlPortletApplicationContext, XmlWebApplicationContext 
		Interface to provide configuration for a web application. This is read-only while the application is running, but may be reloaded if the implementation supports this.
		This interface adds a getServletContext() method to the generic ApplicationContext interface, and defines a well-known application attribute name that the root context must be bound to in the bootstrap process.
		Like generic application contexts, web application contexts are hierarchical. There is a single root context per application, while each servlet in the application (including a dispatcher servlet in the MVC framework) has its own child context.
		In addition to standard application context lifecycle capabilities, WebApplicationContext implementations need to detect ServletContextAware beans and invoke the setServletContext method accordingly.
		ServletContext getServletContext(): 
***	AbstractContextLoaderInitializer: Convenient base class for WebApplicationInitializer implementations that register a ContextLoaderListener in the servlet context.
		The only method required to be implemented by subclasses is createRootApplicationContext(), which gets invoked from registerContextLoaderListener(javax.servlet.ServletContext).
		All Implemented Interfaces:
			WebApplicationInitializer 
		Direct Known Subclasses:
			AbstractDispatcherServletInitializer 
	ContextCleanupListener
****ContextLoader: 非常重要的一个类，要仔细看api文档。Performs the actual initialization work for the root application context. Called by ContextLoaderListener. 
****ContextLoaderListener: ContextLoader的子类, 非常重要的一个类，要仔细看api文档。Bootstrap listener to start up and shut down Spring's root WebApplicationContext. Simply delegates to ContextLoader as well as to ContextCleanupListener. 
		As of Spring 3.1, ContextLoaderListener supports injecting the root web application context via the ContextLoaderListener(WebApplicationContext) constructor, allowing for programmatic configuration in Servlet 3.0+ environments. See WebApplicationInitializer for usage examples.
		
		Create a new ContextLoaderListener with the given application context. This constructor is useful in Servlet 3.0+ environments where instance-based registration of listeners is possible through the ServletContext.addListener(java.lang.String) API.

		The context may or may not yet be refreshed. If it (a) is an implementation of ConfigurableWebApplicationContext and (b) has not already been refreshed (the recommended approach), then the following will occur:

			If the given context has not already been assigned an id, one will be assigned to it
			ServletContext and ServletConfig objects will be delegated to the application context
			ContextLoader.customizeContext(javax.servlet.ServletContext, org.springframework.web.context.ConfigurableWebApplicationContext) will be called
			Any ApplicationContextInitializers specified through the "contextInitializerClasses" init-param will be applied.
			refresh() will be called

		If the context has already been refreshed or does not implement ConfigurableWebApplicationContext, none of the above will occur under the assumption that the user has performed these actions (or not) per his or her specific needs.
		See WebApplicationInitializer for usage examples.
		In any case, the given application context will be registered into the ServletContext under the attribute name WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE and the Spring application context will be closed when the contextDestroyed(javax.servlet.ServletContextEvent) lifecycle method is invoked on this listener.
		
		void  contextInitialized(ServletContextEvent event)
		ContextLoader createContextLoader()
		void contextDestroyed(ServletContextEvent event)
		
		
org.springframework.web.context.request
***	AsyncWebRequestInterceptor:异步请求处理拦截器，下面的描述，精准的把处理流程表达出来了。仔细看
		All Superinterfaces:
			WebRequestInterceptor
		All Known Implementing Classes:
			Log4jNestedDiagnosticContextInterceptor, OpenEntityManagerInViewInterceptor, OpenSessionInViewInterceptor, OpenSessionInViewInterceptor 
		Extends WebRequestInterceptor with a callback method invoked during asynchronous request handling.
		When a handler starts asynchronous request handling, the DispatcherServlet exits without invoking postHandle and afterCompletion, as it normally does, since the results of request handling (e.g. ModelAndView) are not available in the current thread and handling is not yet complete. In such scenarios, the afterConcurrentHandlingStarted(WebRequest) method is invoked instead allowing implementations to perform tasks such as cleaning up thread bound attributes.
		When asynchronous handling completes, the request is dispatched to the container for further processing. At this stage the DispatcherServlet invokes preHandle, postHandle and afterCompletion as usual.
		
		void afterConcurrentHandlingStarted(WebRequest request)
		
	NativeWebRequest:
	RequestAttributes: Abstraction for accessing attribute objects associated with a request. Supports access to request-scoped attributes as well as to session-scoped attributes, with the optional notion of a "global session".
		Can be implemented for any kind of request/session mechanism, in particular for servlet requests and portlet requests.
		
		All Known Subinterfaces:
			AsyncWebRequest, NativeWebRequest, WebRequest

		All Known Implementing Classes:
			AbstractRequestAttributes, DispatcherServletWebRequest, FacesRequestAttributes, FacesWebRequest, NoSupportAsyncWebRequest, PortletRequestAttributes, PortletWebRequest, ServletRequestAttributes, ServletWebRequest, StandardServletAsyncWebRequest 
	
		getAttribute(String name, int scope)
		getAttributeNames(int scope)
		getSessionId()
		getSessionMutex()
		registerDestructionCallback(String name, Runnable callback, int scope)
		removeAttribute(String name, int scope)
		resolveReference(String key)
		setAttribute(String name, Object value, int scope)
	
	
	WebRequest: Generic interface for a web request. Mainly intended for generic web request interceptors, giving them access to general request metadata, not for actual handling of the request.
		All Superinterfaces:
			RequestAttributes

		All Known Subinterfaces:
			AsyncWebRequest, NativeWebRequest

		All Known Implementing Classes:
			DispatcherServletWebRequest, FacesWebRequest, NoSupportAsyncWebRequest, PortletWebRequest, ServletWebRequest, StandardServletAsyncWebRequest 
		checkNotModified(long lastModifiedTimestamp)
		checkNotModified(String eTag)
		getContextPath()
		getDescription(boolean includeClientInfo)
		getHeader(String headerName)
		getHeaderNames()
		getHeaderValues(String headerName)
		getLocale()
		getParameter(String paramName)
		getParameterMap()
		getParameterNames()
		getParameterValues(String paramName)
		getRemoteUser()
		getUserPrincipal()
		isSecure()
		isUserInRole(String role)
		
***	WebRequestInterceptor: interface for general web request interception. Allows for being applied to Servlet request as well as Portlet request environments, by building on the WebRequest abstraction.
		This interface assumes MVC-style request processing: A handler gets executed, exposes a set of model objects, then a view gets rendered based on that model. Alternatively, a handler may also process the request completely, with no view to be rendered.
		In an async processing scenario, the handler may be executed in a separate thread while the main thread exits without rendering or invoking the postHandle and afterCompletion callbacks. 
		When concurrent handler execution completes, the request is dispatched back in order to proceed with rendering the model and all methods of this contract are invoked again. 
		For further options and comments see org.springframework.web.context.request.async.AsyncWebRequestInterceptor
		This interface is deliberately minimalistic to keep the dependencies of generic request interceptors as minimal as feasible.
		NOTE: While this interceptor is applied to the entire request processing in a Servlet environment, it is by default only applied to the render phase in a Portlet environment, 
			preparing and rendering a Portlet view. To apply WebRequestInterceptors to the action phase as well, set the HandlerMapping's "applyWebRequestInterceptorsToRenderPhaseOnly" flag to "false". 
			Alternatively, consider using the Portlet-specific HandlerInterceptor mechanism for such needs.
	AbstractRequestAttributes: Abstract support class for RequestAttributes implementations, offering a request completion mechanism for request-specific destruction callbacks and for updating accessed session attributes.
		public void requestCompleted()
***		protected final boolean isRequestActive(): 这个方法挺有用的, Determine whether the original request is still active.
***		protected final void registerRequestDestructionCallback(String name, Runnable callback): Register the given callback as to be executed after request completion.
		protected final void removeRequestDestructionCallback(String name)
		protected abstract void updateAccessedSessionAttributes()
	AbstractRequestAttributesScope: Abstract Scope implementation that reads from a particular scope in the current thread-bound RequestAttributes object.
		Subclasses simply need to implement getScope() to instruct this class which RequestAttributes scope to read attributes from.
		Subclasses may wish to override the get(java.lang.String, org.springframework.beans.factory.ObjectFactory) and remove(java.lang.String) methods to add synchronization around the call back into this super class.
		get(String name, ObjectFactory objectFactory)
		protected abstract int 	getScope()
		registerDestructionCallback(String name, Runnable callback)
		remove(String name)
		resolveContextualObject(String key)
	DestructionCallbackBindingListener: Adapter that implements the Servlet 2.3 HttpSessionBindingListener interface, wrapping a session destruction callback.
		valueBound(HttpSessionBindingEvent event) 
		valueUnbound(HttpSessionBindingEvent event) 
	FacesRequestAttributes: RequestAttributes adapter for a JSF FacesContext. Used as default in a JSF environment, wrapping the current FacesContext. 
	FacesWebRequest: WebRequest adapter for a JSF FacesContext.
		All Implemented Interfaces:
			NativeWebRequest, RequestAttributes, WebRequest 
	Log4jNestedDiagnosticContextInterceptor: Request logging interceptor that adds a request context message to the Log4J nested diagnostic context (NDC) before the request is processed, removing it again after the request is processed.
	RequestContextHolder: Holder class to expose the web request in the form of a thread-bound RequestAttributes object. The request will be inherited by any child threads spawned by the current thread if the inheritable flag is set to true.
		Use RequestContextListener or RequestContextFilter to expose the current web request. Note that DispatcherServlet and DispatcherPortlet already expose the current request by default.
		static currentRequestAttributes()
		static getRequestAttributes()
		static resetRequestAttributes()
		static setRequestAttributes(RequestAttributes attributes)
		static setRequestAttributes(RequestAttributes attributes, boolean inheritable)
**	RequestContextListener: 
		Servlet 2.4+ listener that exposes the request to the current thread, through both LocaleContextHolder and RequestContextHolder. To be registered as listener in web.xml.
		Alternatively, Spring's RequestContextFilter and Spring's DispatcherServlet also expose the same request context to the current thread. In contrast to this listener, advanced options are available there (e.g. "threadContextInheritable").
		This listener is mainly for use with third-party servlets, e.g. the JSF FacesServlet. Within Spring's own web support, DispatcherServlet's processing is perfectly sufficient.
		requestDestroyed(ServletRequestEvent requestEvent) 
		requestInitialized(ServletRequestEvent requestEvent) 
	RequestScope: extends AbstractRequestAttributesScope
		Relies on a thread-bound RequestAttributes instance, which can be exported through RequestContextListener, RequestContextFilter or DispatcherServlet.
		This Scope will also work for Portlet environments, through an alternate RequestAttributes implementation (as exposed out-of-the-box by Spring's DispatcherPortlet.
	ServletRequestAttributes implements RequestAttributes
		Servlet-based implementation of the RequestAttributes interface.
		Accesses objects from servlet request and HTTP session scope, with no distinction between "session" and "global session".
****ServletWebRequest:WebRequest adapter for an HttpServletRequest.
		All Implemented Interfaces:
			NativeWebRequest, RequestAttributes, WebRequest
		Direct Known Subclasses:
***			DispatcherServletWebRequest, NoSupportAsyncWebRequest, StandardServletAsyncWebRequest 
		getContextPath()
		getDescription(boolean includeClientInfo)
		getHeader(String headerName)
		getHeaderNames()
		getHeaderValues(String headerName)
		getLocale()
		getNativeRequest()
		getNativeRequest(Class<T> requiredType)
		getNativeResponse()
		getNativeResponse(Class<T> requiredType)
		getParameter(String paramName)
		getParameterMap()
		getParameterNames()
		getParameterValues(String paramName)
		getRemoteUser()
		getResponse()
		getUserPrincipal()
		isNotModified() 
		isSecure()
		isUserInRole(String role)
	SessionScope:	
	
	
org.springframework.web.context.request.async	
***	AsyncWebRequest: Extends NativeWebRequest with methods for asynchronous request processing. 异步处理的一个很重要的类
		All Superinterfaces:
			NativeWebRequest, RequestAttributes, WebRequest
		All Known Implementing Classes:
			NoSupportAsyncWebRequest, StandardServletAsyncWebRequest 
		addCompletionHandler(Runnable runnable): Add a handle to invoke when request processing completes.
		addTimeoutHandler(Runnable runnable): Add a handler to invoke when concurrent handling has timed out.
		dispatch(): Dispatch the request to the container in order to resume processing after concurrent execution in an application thread.
		isAsyncComplete(): Whether asynchronous processing has completed.
		isAsyncStarted(): Whether the request is in async mode following a call to startAsync().
		setTimeout(Long timeout): Set the time required for concurrent handling to complete.
	***	startAsync(): Mark the start of asynchronous request processing so that when the main processing thread exits, the response remains open for further processing in another thread.
	
****CallableProcessingInterceptor: 异步处理的一个很重要的类。 Intercepts concurrent request handling, where the concurrent result is obtained by executing a Callable on behalf of the application with an AsyncTaskExecutor.
		All Known Implementing Classes:
			CallableProcessingInterceptorAdapter, TimeoutCallableProcessingInterceptor 
		A CallableProcessingInterceptor is invoked before and after the invocation of the Callable task in the asynchronous thread, as well as on timeout from a container thread, or after completing for any reason including a timeout or network error.
		As a general rule exceptions raised by interceptor methods will cause async processing to resume by dispatching back to the container and using the Exception instance as the concurrent result. Such exceptions will then be processed through the HandlerExceptionResolver mechanism.
		The afterTimeout method can select a value to be used to resume processing.
		afterCompletion(NativeWebRequest request, Callable<T> task): Invoked from a container thread when async processing completes for any reason including timeout or network error.
		beforeConcurrentHandling(NativeWebRequest request, Callable<T> task): Invoked before the start of concurrent handling in the original thread in which the Callable is submitted for concurrent handling.
			This is useful for capturing the state of the current thread just prior to invoking the Callable. Once the state is captured, it can then be transfered to the new Thread in preProcess(NativeWebRequest, Callable). Capturing the state of Spring Security's SecurityContextHolder and migrating it to the new Thread is a concrete example of where this is useful. 
		handleTimeout(NativeWebRequest request, Callable<T> task): Invoked from a container thread when the async request times out before the Callable task completes. Implementations may return a value, including an Exception, to use instead of the value the Callable did not return in time.
		postProcess(NativeWebRequest request, Callable<T> task, Object concurrentResult): Invoked after the Callable has produced a result in the async thread in which the Callable is executed. This method may be invoked later than afterTimeout or afterCompletion depending on when the Callable finishes processing.
		preProcess(NativeWebRequest request, Callable<T> task): Invoked after the start of concurrent handling in the async thread in which the Callable is executed and before the actual invocation of the Callable.
	DeferredResult.DeferredResultHandler:延期的
		Handles a DeferredResult value when set.
		handleResult(Object result) 
**	DeferredResultProcessingInterceptor: 
		Intercepts concurrent request handling, where the concurrent result is obtained by waiting for a DeferredResult to be set from a thread chosen by the application (e.g. in response to some external event).
		A DeferredResultProcessingInterceptor is invoked before the start of async processing, after the DeferredResult is set as well as on timeout, or or after completing for any reason including a timeout or network error.
		As a general rule exceptions raised by interceptor methods will cause async processing to resume by dispatching back to the container and using the Exception instance as the concurrent result. Such exceptions will then be processed through the HandlerExceptionResolver mechanism.
		The afterTimeout method can set the DeferredResult in order to resume processing.
		afterCompletion(NativeWebRequest request, DeferredResult<T> deferredResult)
		beforeConcurrentHandling(NativeWebRequest request, DeferredResult<T> deferredResult)
		handleTimeout(NativeWebRequest request, DeferredResult<T> deferredResult)
		postProcess(NativeWebRequest request, DeferredResult<T> deferredResult, Object concurrentResult)
		preProcess(NativeWebRequest request, DeferredResult<T> deferredResult): Invoked immediately after the start of concurrent handling, in the same thread that started it.
	CallableProcessingInterceptorAdapter: Abstract adapter class for the CallableProcessingInterceptor interface, for simplified implementation of individual methods.
		方法基本都是空的
**	DeferredResult: 异步处理结果类，
		DeferredResult provides an alternative to using a Callable for asynchronous request processing. While a Callable is executed concurrently on behalf of the application, with a DeferredResult the application can produce the result from a thread of its choice.
		Subclasses can extend this class to easily associate additional data or behavior with the DeferredResult. For example, one might want to associate the user used to create the DeferredResult by extending the class and adding an additional property for the user. In this way, the user could easily be accessed later without the need to use a data structure to do the mapping.
		An example of associating additional behavior to this class might be realized by extending the class to implement an additional interface. For example, one might want to implement Comparable so that when the DeferredResult is added to a PriorityQueue it is handled in the correct order.
		isSetOrExpired():
*		onCompletion(Runnable callback): Register code to invoke when the async request completes. This method is called from a container thread when an async request completed for any reason including timeout and network error. This method is useful for detecting that a DeferredResult instance is no longer usable.
		onTimeout(Runnable callback)
		setErrorResult(Object result)
*		setResult(T result): Set the value for the DeferredResult and handle it.
		setResultHandler(DeferredResult.DeferredResultHandler resultHandler): Provide a handler to use to handle the result value.
	DeferredResultProcessingInterceptorAdapter: Abstract adapter class for the DeferredResultProcessingInterceptor interface for simplified implementation of individual methods.
**	NoSupportAsyncWebRequest: An AsyncWebRequest to use when there is no underlying async support.
		org.springframework.web.context.request.AbstractRequestAttributes
			org.springframework.web.context.request.ServletRequestAttributes
				org.springframework.web.context.request.ServletWebRequest
					org.springframework.web.context.request.async.NoSupportAsyncWebRequest
		addCompletionHandler(Runnable runnable)
		addTimeoutHandler(Runnable runnable)
		dispatch(): Dispatch the request to the container in order to resume processing after concurrent execution in an application thread.
		isAsyncComplete(): 
		isAsyncStarted(): 
		setTimeout(Long timeout): 
		startAsync(): 
****StandardServletAsyncWebRequest: 要在web.xml里面配置参数<async-support>true</async-support>以支持异步操作。猜测是异步操作的基础(不确定)
		org.springframework.web.context.request.AbstractRequestAttributes
			org.springframework.web.context.request.ServletRequestAttributes
				org.springframework.web.context.request.ServletWebRequest
					org.springframework.web.context.request.async.StandardServletAsyncWebRequest
		The servlet and all filters involved in an async request must have async support enabled using the Servlet API or by adding an <async-support>true</async-support> element to servlet and filter declarations in web.xml
	
	
	
HtmlUtils
JavaScriptUtils
UriComponents.encode()
UriComponentsBuilder
	UriTemplate template = new UriTemplate("http://example.com/hotels/{hotel}/bookings/{booking}");
	System.out.println(template.match("http://example.com/hotels/1/bookings/42"));
UrlPathHelper：得到uri的部分内容，比较有用
WebUtils：比较有用