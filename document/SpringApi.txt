org.springframework.web：
	WebApplicationInitializer <-----|
		 <servlet>
		   <servlet-name>dispatcher</servlet-name>
		   <servlet-class>
			 org.springframework.web.servlet.DispatcherServlet
		   </servlet-class>
		   <init-param>
			 <param-name>contextConfigLocation</param-name>
			 <param-value>/WEB-INF/spring/dispatcher-config.xml</param-value>
		   </init-param>
		   <load-on-startup>1</load-on-startup>
		 </servlet>

		 <servlet-mapping>
		   <servlet-name>dispatcher</servlet-name>
		   <url-pattern>/</url-pattern>
		 </servlet-mapping>
	
		 ===========================================================================================
		 public class MyWebAppInitializer implements WebApplicationInitializer {

			@Override
			public void onStartup(ServletContext container) {
			  XmlWebApplicationContext appContext = new XmlWebApplicationContext();
			  appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

			  ServletRegistration.Dynamic dispatcher =
				container.addServlet("dispatcher", new DispatcherServlet(appContext));
			  dispatcher.setLoadOnStartup(1);
			  dispatcher.addMapping("/");
			}

		 }
		
		 ===========================================================================================
		@Override
		public void onStartup(ServletContext container) {
		  // Create the 'root' Spring application context
		  AnnotationConfigWebApplicationContext rootContext =
			new AnnotationConfigWebApplicationContext();
		  rootContext.register(AppConfig.class);

		  // Manage the lifecycle of the root application context
		  container.addListener(new ContextLoaderListener(rootContext));

		  // Create the dispatcher servlet's Spring application context
		  AnnotationConfigWebApplicationContext dispatcherContext =
			new AnnotationConfigWebApplicationContext();
		  dispatcherContext.register(DispatcherConfig.class);

		  // Register and map the dispatcher servlet
		  ServletRegistration.Dynamic dispatcher =
			container.addServlet("dispatcher", new DispatcherServlet(dispatcherContext));
		  dispatcher.setLoadOnStartup(1);
		  dispatcher.addMapping("/");
		}

				 
	
	SpringServletContainerInitializer：猜测这个是spring web启动的起点

org.springframework.web.accept

org.springframework.web.bind
	EscapedErrors:有很多rejectValue(......)方法。Errors wrapper that adds automatic HTML escaping to the wrapped instance, for convenient usage in HTML views. Can be retrieved easily via RequestContext's getErrors method. 
	ServletRequestDataBinder
		例子：
			 MyBean myBean = new MyBean();
			 // apply binder to custom target object
			 ServletRequestDataBinder binder = new ServletRequestDataBinder(myBean);
			 // register custom editors, if desired
			 binder.registerCustomEditor(...);
			 // trigger actual binding of request parameters
			 binder.bind(request);
			 // optionally evaluate binding errors
			 Errors errors = binder.getErrors();
	ServletRequestParameterPropertyValues
	ServletRequestUtils，里面有很多从request里得到值的方法
	WebDataBinder（子类：PortletRequestDataBinder, ServletRequestDataBinder, WebRequestDataBinder）

org.springframework.web.bind.annotation.support
	HandlerMethodInvoker
	HandlerMethodResolver
	
	
org.springframework.web.bind.annotation：	里面定义了很多annotation，可以在很多地方使用
	ExceptionHandler：被它声明的方法，可以捕获特定的exception
	MatrixVariable
	ModelAttribute
	RequestHeader
	RequestMapping
	RequestBody: 用于没有上传文件的form
	RequestPart：用于有上传文件的form。@RequestParam annotation can also be used to associate the part of a "multipart/form-data" request with a method argument supporting the same method argument types. The main difference is that when the method argument is not a String, @RequestParam relies on type conversion via a registered Converter or PropertyEditor while @RequestPart relies on HttpMessageConverters taking into consideration the 'Content-Type' header of the request part. @RequestParam is likely to be used with name-value form fields while @RequestPart is likely to be used with parts containing more complex content (e.g. JSON, XML).
	ResponseStatus
	SessionStatus.setComplete()
	
org.springframework.web.bind.annotation.support
	HandlerMethodInvoker:Used by AnnotationMethodHandlerAdapter and AnnotationMethodHandlerAdapter.   <====== 是个很重要的类
		有很多类似resolveRequestBody() / resolveCookieValue()这样的方法
	HandlerMethodResolver:Support class for resolving web method annotations in a handler type. Processes @RequestMapping, @InitBinder, @ModelAttribute and @SessionAttributes. 
		Used by AnnotationMethodHandlerAdapter and AnnotationMethodHandlerAdapter.

org.springframework.web.bind.support
    SessionAttributeStore
    SessionStatus
*** WebArgumentResolver: 可以处理controller中具体方法的某个参数，非常有用的东东
    WebBindingInitializer: Callback interface for initializing a WebDataBinder for performing data binding in the context of a specific web request.
		initBinder(WebDataBinder binder, WebRequest request)：当request来时，对绑定的binder进行初始化
    WebDataBinderFactory
		WebDataBinder createBinder(NativeWebRequest webRequest,
                         Object target,
                         String objectName)
                           throws Exception		创建一个webDataBinder
						   
	ConfigurableWebBindingInitializer: Convenient WebBindingInitializer for declarative configuration in a Spring application context. Allows for reusing pre-configured initializers with multiple controller/handlers.
	DefaultDataBinderFactory: 
		initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest): Extension point to further initialize the created data binder instance (e.g.
	DefaultSessionAttributeStore:
		setAttributeNamePrefix
		storeAttribute(WebRequest request, String attributeName,  Object attributeValue)
		Object retrieveAttribute(WebRequest request, String attributeName)
		void cleanupAttribute(WebRequest request, String attributeName)
	SimpleSessionStatus
		isComplete()
		setComplete()
	WebRequestDataBinder: Special DataBinder to perform data binding from web request parameters to JavaBeans, including support for multipart files. 
		 MyBean myBean = new MyBean();
		 // apply binder to custom target object
		 WebRequestDataBinder binder = new WebRequestDataBinder(myBean);
		 // register custom editors, if desired
		 binder.registerCustomEditor(...);
		 // trigger actual binding of request parameters
		 binder.bind(request);
		 // optionally evaluate binding errors
		 Errors errors = binder.getErrors();
		
		public void bind(WebRequest request):
			Bind the parameters of the given request to this binder's target, also binding multipart files in case of a multipart request.
			This call can create field errors, representing basic binding errors like a required field (code "required"), or type mismatch between value and bean property (code "typeMismatch").
			Multipart files are bound via their parameter name, just like normal HTTP parameters: i.e. "uploadedFile" to an "uploadedFile" bean property, invoking a "setUploadedFile" setter method.
			The type of the target property for a multipart file can be MultipartFile, byte[], or String. The latter two receive the contents of the uploaded file; all metadata like original file name, content type, etc are lost in those cases.

			
org.springframework.web.client
	RequestCallback: Callback interface for code that operates on a ClientHttpRequest. Allows to manipulate the request headers, and write to the request body. 
		Used internally by the RestTemplate, but also useful for application code.
		
		void doWithRequest(ClientHttpRequest request) throws IOException : Gets called by RestTemplate.execute(java.lang.String, org.springframework.http.HttpMethod, org.springframework.web.client.RequestCallback, org.springframework.web.client.ResponseExtractor<T>, java.lang.Object...) with an opened ClientHttpRequest. 
			Does not need to care about closing the request or about handling errors: this will all be handled by the RestTemplate.
	
	ResponseErrorHandler: Strategy interface used by the RestTemplate to determine whether a particular response has an error or not.
	ResponseExtractor<T>: Generic callback interface used by RestTemplate's retrieval methods Implementations of this interface perform the actual work of extracting data from a ClientHttpResponse, but don't need to worry about exception handling or closing resources.
							Used internally by the RestTemplate, but also useful for application code.
		T extractData(ClientHttpResponse response) throws IOException : Extract data from the given ClientHttpResponse and return it.
	RestOperations: Interface specifying a basic set of RESTful operations. Implemented by RestTemplate. Not often used directly, but a useful option to enhance testability, as it can easily be mocked or stubbed.
		在test时候会用
	
	DefaultResponseErrorHandler： This error handler checks for the status code on the ClientHttpResponse: any code with series HttpStatus.Series.CLIENT_ERROR or HttpStatus.Series.SERVER_ERROR is considered to be an error. 
		This behavior can be changed by overriding the hasError(HttpStatus) method.
	HttpMessageConverterExtractor<T>： Response extractor that uses the given entity converters to convert the response into a type T.
		public HttpMessageConverterExtractor(Class<T> responseType,
                             List<HttpMessageConverter<?>> messageConverters): Creates a new instance of the HttpMessageConverterExtractor with the given response type and message converters. The given converters must support the response type.
		public HttpMessageConverterExtractor(Type responseType,
                             List<HttpMessageConverter<?>> messageConverters): Creates a new instance of the HttpMessageConverterExtractor with the given response type and message converters. The given converters must support the response type.
							 
***	RestTemplate extends InterceptingHttpAccessor implements RestOperations:非常有用的一个测试url的东东
		The central class for client-side HTTP access. It simplifies communication with HTTP servers, and enforces RESTful principles. It handles HTTP connections, leaving application code to provide URLs (with possible template variables) and extract results. 
		The exchange and execute methods are generalized versions of the more specific methods listed above them. They support additional, less frequently used combinations including support for requests using the HTTP PATCH method. However, note that the underlying HTTP library must also support the desired combination.
		For each of these HTTP methods, there are three corresponding Java methods in the RestTemplate. Two variant take a String URI as first argument (eg. getForObject(String, Class, Object[]), getForObject(String, Class, Map)), and are capable of substituting any URI templates in that URL using either a String variable arguments array, or a Map<String, String>. The string varargs variant expands the given template variables in order, so that
		 String result = restTemplate.getForObject("http://example.com/hotels/{hotel}/bookings/{booking}", String.class,"42",
		 "21");

		will perform a GET on http://example.com/hotels/42/bookings/21. The map variant expands the template based on variable name, and is therefore more useful when using many variables, or when a single variable is used multiple times. For example:

		 Map<String, String> vars = Collections.singletonMap("hotel", "42");
		 String result = restTemplate.getForObject("http://example.com/hotels/{hotel}/rooms/{hotel}", String.class, vars);
		will perform a GET on http://example.com/hotels/42/rooms/42. Alternatively, there are URI variant methods (getForObject(URI, Class)), which do not allow for URI templates, but allow you to reuse a single, expanded URI multiple times.

		Furthermore, the String-argument methods assume that the URL String is unencoded. This means that
		 restTemplate.getForObject("http://example.com/hotel list");
		will perform a GET on http://example.com/hotel%20list. As a result, any URL passed that is already encoded will be encoded twice (i.e. http://example.com/hotel%20list will become http://example.com/hotel%2520list). If this behavior is undesirable, use the URI-argument methods, which will not perform any URL encoding.

		Objects passed to and returned from these methods are converted to and from HTTP messages by HttpMessageConverter instances. Converters for the main mime types are registered by default, but you can also write your own converter and register it via the messageConverters bean property.
		This template uses a SimpleClientHttpRequestFactory and a DefaultResponseErrorHandler as default strategies for creating HTTP connections or handling HTTP errors, respectively. These defaults can be overridden through the requestFactory and errorHandler bean properties.
	
	HttpClientErrorException: Exception thrown when an HTTP 4xx is received.
	HttpServerErrorException: Exception thrown when an HTTP 5xx is received.
		public HttpHeaders getResponseHeaders()
		public byte[] getResponseBodyAsByteArray()
		public String getResponseBodyAsString()
	ResourceAccessException: Exception thrown when an I/O error occurs.
	RestClientException extends NestedRuntimeException: Base class for exceptions thrown by RestTemplate whenever it encounters client-side HTTP errors.
	UnknownHttpStatusCodeException: Exception thrown when an unknown (or custom) HTTP status code is received.
		getRawStatusCode(): Return the raw HTTP status code value.
		getResponseBodyAsByteArray(): Return the response body as a byte array.
		getResponseBodyAsString(): Return the response body as a string.
		getResponseHeaders(): Return the HTTP response headers.
		getStatusText(): Return the HTTP status text.

		
org.springframework.web.client.support
	RestGatewaySupport: Convenient super class for application classes that need REST access. Requires a ClientHttpRequestFactory or a RestTemplate instance to be set.


org.springframework.web.context
***	ConfigurableWebApplicationContext: 
		All Superinterfaces:
			ApplicationContext, ApplicationEventPublisher, AutoCloseable, BeanFactory, Closeable, ConfigurableApplicationContext, EnvironmentCapable, HierarchicalBeanFactory, Lifecycle, ListableBeanFactory, MessageSource, ResourceLoader, ResourcePatternResolver, WebApplicationContext 
		All Known Implementing Classes:
			AbstractRefreshableWebApplicationContext, AnnotationConfigWebApplicationContext, GenericWebApplicationContext, StaticWebApplicationContext, XmlWebApplicationContext 
	ConfigurableWebEnvironment extends ConfigurableEnvironment: Specialization of ConfigurableEnvironment allowing initialization of servlet-related PropertySource objects at the earliest moment that the ServletContext and (optionally) ServletConfig become available.
		void initPropertySources(ServletContext servletContext, ServletConfig servletConfig): Replace any stub property source instances acting as placeholders with real servlet context/config property sources using the given parameters.
***	ServletConfigAware: 非常有用的一个类，
		Interface to be implemented by any object that wishes to be notified of the ServletConfig (typically determined by the WebApplicationContext) that it runs in.
		Note: Only satisfied if actually running within a Servlet-specific WebApplicationContext. Otherwise, no ServletConfig will be set.
		void setServletConfig(ServletConfig servletConfig)： Set the ServletConfig that this object runs in.
			Invoked after population of normal bean properties but before an init callback like InitializingBean's afterPropertiesSet or a custom init-method. Invoked after ApplicationContextAware's setApplicationContext.
***	WebApplicationContext: 非常有用的一个类，
		All Superinterfaces:
			ApplicationContext, ApplicationEventPublisher, BeanFactory, EnvironmentCapable, HierarchicalBeanFactory, ListableBeanFactory, MessageSource, ResourceLoader, ResourcePatternResolver
		All Known Subinterfaces:
			ConfigurablePortletApplicationContext, ConfigurableWebApplicationContext
		All Known Implementing Classes:
			AbstractRefreshablePortletApplicationContext, AbstractRefreshableWebApplicationContext, AnnotationConfigWebApplicationContext, GenericWebApplicationContext, StaticPortletApplicationContext, StaticWebApplicationContext, XmlPortletApplicationContext, XmlWebApplicationContext 
		Interface to provide configuration for a web application. This is read-only while the application is running, but may be reloaded if the implementation supports this.
		This interface adds a getServletContext() method to the generic ApplicationContext interface, and defines a well-known application attribute name that the root context must be bound to in the bootstrap process.
		Like generic application contexts, web application contexts are hierarchical. There is a single root context per application, while each servlet in the application (including a dispatcher servlet in the MVC framework) has its own child context.
		In addition to standard application context lifecycle capabilities, WebApplicationContext implementations need to detect ServletContextAware beans and invoke the setServletContext method accordingly.
		ServletContext getServletContext(): 
***	AbstractContextLoaderInitializer: Convenient base class for WebApplicationInitializer implementations that register a ContextLoaderListener in the servlet context.
		The only method required to be implemented by subclasses is createRootApplicationContext(), which gets invoked from registerContextLoaderListener(javax.servlet.ServletContext).
		All Implemented Interfaces:
			WebApplicationInitializer 
		Direct Known Subclasses:
			AbstractDispatcherServletInitializer 
	ContextCleanupListener
****ContextLoader: 非常重要的一个类，要仔细看api文档。Performs the actual initialization work for the root application context. Called by ContextLoaderListener. 
****ContextLoaderListener: ContextLoader的子类, 非常重要的一个类，要仔细看api文档。Bootstrap listener to start up and shut down Spring's root WebApplicationContext. Simply delegates to ContextLoader as well as to ContextCleanupListener. 
		As of Spring 3.1, ContextLoaderListener supports injecting the root web application context via the ContextLoaderListener(WebApplicationContext) constructor, allowing for programmatic configuration in Servlet 3.0+ environments. See WebApplicationInitializer for usage examples.
		
		Create a new ContextLoaderListener with the given application context. This constructor is useful in Servlet 3.0+ environments where instance-based registration of listeners is possible through the ServletContext.addListener(java.lang.String) API.

		The context may or may not yet be refreshed. If it (a) is an implementation of ConfigurableWebApplicationContext and (b) has not already been refreshed (the recommended approach), then the following will occur:

			If the given context has not already been assigned an id, one will be assigned to it
			ServletContext and ServletConfig objects will be delegated to the application context
			ContextLoader.customizeContext(javax.servlet.ServletContext, org.springframework.web.context.ConfigurableWebApplicationContext) will be called
			Any ApplicationContextInitializers specified through the "contextInitializerClasses" init-param will be applied.
			refresh() will be called

		If the context has already been refreshed or does not implement ConfigurableWebApplicationContext, none of the above will occur under the assumption that the user has performed these actions (or not) per his or her specific needs.
		See WebApplicationInitializer for usage examples.
		In any case, the given application context will be registered into the ServletContext under the attribute name WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE and the Spring application context will be closed when the contextDestroyed(javax.servlet.ServletContextEvent) lifecycle method is invoked on this listener.
		
		void  contextInitialized(ServletContextEvent event)
		ContextLoader createContextLoader()
		void contextDestroyed(ServletContextEvent event)
		
		
org.springframework.web.context.request
***	AsyncWebRequestInterceptor:异步请求处理拦截器，下面的描述，精准的把处理流程表达出来了。仔细看
		All Superinterfaces:
			WebRequestInterceptor
		All Known Implementing Classes:
			Log4jNestedDiagnosticContextInterceptor, OpenEntityManagerInViewInterceptor, OpenSessionInViewInterceptor, OpenSessionInViewInterceptor 
		Extends WebRequestInterceptor with a callback method invoked during asynchronous request handling.
		When a handler starts asynchronous request handling, the DispatcherServlet exits without invoking postHandle and afterCompletion, as it normally does, since the results of request handling (e.g. ModelAndView) are not available in the current thread and handling is not yet complete. In such scenarios, the afterConcurrentHandlingStarted(WebRequest) method is invoked instead allowing implementations to perform tasks such as cleaning up thread bound attributes.
		When asynchronous handling completes, the request is dispatched to the container for further processing. At this stage the DispatcherServlet invokes preHandle, postHandle and afterCompletion as usual.
		
		void afterConcurrentHandlingStarted(WebRequest request)
		
	NativeWebRequest:
	RequestAttributes: Abstraction for accessing attribute objects associated with a request. Supports access to request-scoped attributes as well as to session-scoped attributes, with the optional notion of a "global session".
		Can be implemented for any kind of request/session mechanism, in particular for servlet requests and portlet requests.
		
		All Known Subinterfaces:
			AsyncWebRequest, NativeWebRequest, WebRequest

		All Known Implementing Classes:
			AbstractRequestAttributes, DispatcherServletWebRequest, FacesRequestAttributes, FacesWebRequest, NoSupportAsyncWebRequest, PortletRequestAttributes, PortletWebRequest, ServletRequestAttributes, ServletWebRequest, StandardServletAsyncWebRequest 
	
		getAttribute(String name, int scope)
		getAttributeNames(int scope)
		getSessionId()
		getSessionMutex()
		registerDestructionCallback(String name, Runnable callback, int scope)
		removeAttribute(String name, int scope)
		resolveReference(String key)
		setAttribute(String name, Object value, int scope)
	
	
	WebRequest: Generic interface for a web request. Mainly intended for generic web request interceptors, giving them access to general request metadata, not for actual handling of the request.
		All Superinterfaces:
			RequestAttributes

		All Known Subinterfaces:
			AsyncWebRequest, NativeWebRequest

		All Known Implementing Classes:
			DispatcherServletWebRequest, FacesWebRequest, NoSupportAsyncWebRequest, PortletWebRequest, ServletWebRequest, StandardServletAsyncWebRequest 
		checkNotModified(long lastModifiedTimestamp)
		checkNotModified(String eTag)
		getContextPath()
		getDescription(boolean includeClientInfo)
		getHeader(String headerName)
		getHeaderNames()
		getHeaderValues(String headerName)
		getLocale()
		getParameter(String paramName)
		getParameterMap()
		getParameterNames()
		getParameterValues(String paramName)
		getRemoteUser()
		getUserPrincipal()
		isSecure()
		isUserInRole(String role)
		
***	WebRequestInterceptor: interface for general web request interception. Allows for being applied to Servlet request as well as Portlet request environments, by building on the WebRequest abstraction.
		This interface assumes MVC-style request processing: A handler gets executed, exposes a set of model objects, then a view gets rendered based on that model. Alternatively, a handler may also process the request completely, with no view to be rendered.
		In an async processing scenario, the handler may be executed in a separate thread while the main thread exits without rendering or invoking the postHandle and afterCompletion callbacks. 
		When concurrent handler execution completes, the request is dispatched back in order to proceed with rendering the model and all methods of this contract are invoked again. 
		For further options and comments see org.springframework.web.context.request.async.AsyncWebRequestInterceptor
		This interface is deliberately minimalistic to keep the dependencies of generic request interceptors as minimal as feasible.
		NOTE: While this interceptor is applied to the entire request processing in a Servlet environment, it is by default only applied to the render phase in a Portlet environment, 
			preparing and rendering a Portlet view. To apply WebRequestInterceptors to the action phase as well, set the HandlerMapping's "applyWebRequestInterceptorsToRenderPhaseOnly" flag to "false". 
			Alternatively, consider using the Portlet-specific HandlerInterceptor mechanism for such needs.
	AbstractRequestAttributes: Abstract support class for RequestAttributes implementations, offering a request completion mechanism for request-specific destruction callbacks and for updating accessed session attributes.
		public void requestCompleted()
***		protected final boolean isRequestActive(): 这个方法挺有用的, Determine whether the original request is still active.
***		protected final void registerRequestDestructionCallback(String name, Runnable callback): Register the given callback as to be executed after request completion.
		protected final void removeRequestDestructionCallback(String name)
		protected abstract void updateAccessedSessionAttributes()
	AbstractRequestAttributesScope: Abstract Scope implementation that reads from a particular scope in the current thread-bound RequestAttributes object.
		Subclasses simply need to implement getScope() to instruct this class which RequestAttributes scope to read attributes from.
		Subclasses may wish to override the get(java.lang.String, org.springframework.beans.factory.ObjectFactory) and remove(java.lang.String) methods to add synchronization around the call back into this super class.
		get(String name, ObjectFactory objectFactory)
		protected abstract int 	getScope()
		registerDestructionCallback(String name, Runnable callback)
		remove(String name)
		resolveContextualObject(String key)
	DestructionCallbackBindingListener: Adapter that implements the Servlet 2.3 HttpSessionBindingListener interface, wrapping a session destruction callback.
		valueBound(HttpSessionBindingEvent event) 
		valueUnbound(HttpSessionBindingEvent event) 
	FacesRequestAttributes: RequestAttributes adapter for a JSF FacesContext. Used as default in a JSF environment, wrapping the current FacesContext. 
	FacesWebRequest: WebRequest adapter for a JSF FacesContext.
		All Implemented Interfaces:
			NativeWebRequest, RequestAttributes, WebRequest 
	Log4jNestedDiagnosticContextInterceptor: Request logging interceptor that adds a request context message to the Log4J nested diagnostic context (NDC) before the request is processed, removing it again after the request is processed.
	RequestContextHolder: Holder class to expose the web request in the form of a thread-bound RequestAttributes object. The request will be inherited by any child threads spawned by the current thread if the inheritable flag is set to true.
		Use RequestContextListener or RequestContextFilter to expose the current web request. Note that DispatcherServlet and DispatcherPortlet already expose the current request by default.
		static currentRequestAttributes()
		static getRequestAttributes()
		static resetRequestAttributes()
		static setRequestAttributes(RequestAttributes attributes)
		static setRequestAttributes(RequestAttributes attributes, boolean inheritable)
**	RequestContextListener: 
		Servlet 2.4+ listener that exposes the request to the current thread, through both LocaleContextHolder and RequestContextHolder. To be registered as listener in web.xml.
		Alternatively, Spring's RequestContextFilter and Spring's DispatcherServlet also expose the same request context to the current thread. In contrast to this listener, advanced options are available there (e.g. "threadContextInheritable").
		This listener is mainly for use with third-party servlets, e.g. the JSF FacesServlet. Within Spring's own web support, DispatcherServlet's processing is perfectly sufficient.
		requestDestroyed(ServletRequestEvent requestEvent) 
		requestInitialized(ServletRequestEvent requestEvent) 
	RequestScope: extends AbstractRequestAttributesScope
		Relies on a thread-bound RequestAttributes instance, which can be exported through RequestContextListener, RequestContextFilter or DispatcherServlet.
		This Scope will also work for Portlet environments, through an alternate RequestAttributes implementation (as exposed out-of-the-box by Spring's DispatcherPortlet.
	ServletRequestAttributes implements RequestAttributes
		Servlet-based implementation of the RequestAttributes interface.
		Accesses objects from servlet request and HTTP session scope, with no distinction between "session" and "global session".
****ServletWebRequest:WebRequest adapter for an HttpServletRequest.
		All Implemented Interfaces:
			NativeWebRequest, RequestAttributes, WebRequest
		Direct Known Subclasses:
***			DispatcherServletWebRequest, NoSupportAsyncWebRequest, StandardServletAsyncWebRequest 
		getContextPath()
		getDescription(boolean includeClientInfo)
		getHeader(String headerName)
		getHeaderNames()
		getHeaderValues(String headerName)
		getLocale()
		getNativeRequest()
		getNativeRequest(Class<T> requiredType)
		getNativeResponse()
		getNativeResponse(Class<T> requiredType)
		getParameter(String paramName)
		getParameterMap()
		getParameterNames()
		getParameterValues(String paramName)
		getRemoteUser()
		getResponse()
		getUserPrincipal()
		isNotModified() 
		isSecure()
		isUserInRole(String role)
	SessionScope:	
	
	
org.springframework.web.context.request.async	
***	AsyncWebRequest: Extends NativeWebRequest with methods for asynchronous request processing. 异步处理的一个很重要的类
		All Superinterfaces:
			NativeWebRequest, RequestAttributes, WebRequest
		All Known Implementing Classes:
			NoSupportAsyncWebRequest, StandardServletAsyncWebRequest 
		addCompletionHandler(Runnable runnable): Add a handle to invoke when request processing completes.
		addTimeoutHandler(Runnable runnable): Add a handler to invoke when concurrent handling has timed out.
		dispatch(): Dispatch the request to the container in order to resume processing after concurrent execution in an application thread.
		isAsyncComplete(): Whether asynchronous processing has completed.
		isAsyncStarted(): Whether the request is in async mode following a call to startAsync().
		setTimeout(Long timeout): Set the time required for concurrent handling to complete.
	***	startAsync(): Mark the start of asynchronous request processing so that when the main processing thread exits, the response remains open for further processing in another thread.
	
****CallableProcessingInterceptor: 异步处理的一个很重要的类。 Intercepts concurrent request handling, where the concurrent result is obtained by executing a Callable on behalf of the application with an AsyncTaskExecutor.
		All Known Implementing Classes:
			CallableProcessingInterceptorAdapter, TimeoutCallableProcessingInterceptor 
		A CallableProcessingInterceptor is invoked before and after the invocation of the Callable task in the asynchronous thread, as well as on timeout from a container thread, or after completing for any reason including a timeout or network error.
		As a general rule exceptions raised by interceptor methods will cause async processing to resume by dispatching back to the container and using the Exception instance as the concurrent result. Such exceptions will then be processed through the HandlerExceptionResolver mechanism.
		The afterTimeout method can select a value to be used to resume processing.
		afterCompletion(NativeWebRequest request, Callable<T> task): Invoked from a container thread when async processing completes for any reason including timeout or network error.
		beforeConcurrentHandling(NativeWebRequest request, Callable<T> task): Invoked before the start of concurrent handling in the original thread in which the Callable is submitted for concurrent handling.
			This is useful for capturing the state of the current thread just prior to invoking the Callable. Once the state is captured, it can then be transfered to the new Thread in preProcess(NativeWebRequest, Callable). Capturing the state of Spring Security's SecurityContextHolder and migrating it to the new Thread is a concrete example of where this is useful. 
		handleTimeout(NativeWebRequest request, Callable<T> task): Invoked from a container thread when the async request times out before the Callable task completes. Implementations may return a value, including an Exception, to use instead of the value the Callable did not return in time.
		postProcess(NativeWebRequest request, Callable<T> task, Object concurrentResult): Invoked after the Callable has produced a result in the async thread in which the Callable is executed. This method may be invoked later than afterTimeout or afterCompletion depending on when the Callable finishes processing.
		preProcess(NativeWebRequest request, Callable<T> task): Invoked after the start of concurrent handling in the async thread in which the Callable is executed and before the actual invocation of the Callable.
	DeferredResult.DeferredResultHandler:延期的
		Handles a DeferredResult value when set.
		handleResult(Object result) 
**	DeferredResultProcessingInterceptor: 
		Intercepts concurrent request handling, where the concurrent result is obtained by waiting for a DeferredResult to be set from a thread chosen by the application (e.g. in response to some external event).
		A DeferredResultProcessingInterceptor is invoked before the start of async processing, after the DeferredResult is set as well as on timeout, or or after completing for any reason including a timeout or network error.
		As a general rule exceptions raised by interceptor methods will cause async processing to resume by dispatching back to the container and using the Exception instance as the concurrent result. Such exceptions will then be processed through the HandlerExceptionResolver mechanism.
		The afterTimeout method can set the DeferredResult in order to resume processing.
		afterCompletion(NativeWebRequest request, DeferredResult<T> deferredResult)
		beforeConcurrentHandling(NativeWebRequest request, DeferredResult<T> deferredResult)
		handleTimeout(NativeWebRequest request, DeferredResult<T> deferredResult)
		postProcess(NativeWebRequest request, DeferredResult<T> deferredResult, Object concurrentResult)
		preProcess(NativeWebRequest request, DeferredResult<T> deferredResult): Invoked immediately after the start of concurrent handling, in the same thread that started it.
	CallableProcessingInterceptorAdapter: Abstract adapter class for the CallableProcessingInterceptor interface, for simplified implementation of individual methods.
		方法基本都是空的
**	DeferredResult: 异步处理结果类，
		DeferredResult provides an alternative to using a Callable for asynchronous request processing. While a Callable is executed concurrently on behalf of the application, with a DeferredResult the application can produce the result from a thread of its choice.
		Subclasses can extend this class to easily associate additional data or behavior with the DeferredResult. For example, one might want to associate the user used to create the DeferredResult by extending the class and adding an additional property for the user. In this way, the user could easily be accessed later without the need to use a data structure to do the mapping.
		An example of associating additional behavior to this class might be realized by extending the class to implement an additional interface. For example, one might want to implement Comparable so that when the DeferredResult is added to a PriorityQueue it is handled in the correct order.
		isSetOrExpired():
*		onCompletion(Runnable callback): Register code to invoke when the async request completes. This method is called from a container thread when an async request completed for any reason including timeout and network error. This method is useful for detecting that a DeferredResult instance is no longer usable.
		onTimeout(Runnable callback)
		setErrorResult(Object result)
*		setResult(T result): Set the value for the DeferredResult and handle it.
		setResultHandler(DeferredResult.DeferredResultHandler resultHandler): Provide a handler to use to handle the result value.
	DeferredResultProcessingInterceptorAdapter: Abstract adapter class for the DeferredResultProcessingInterceptor interface for simplified implementation of individual methods.
**	NoSupportAsyncWebRequest: An AsyncWebRequest to use when there is no underlying async support.
		org.springframework.web.context.request.AbstractRequestAttributes
			org.springframework.web.context.request.ServletRequestAttributes
				org.springframework.web.context.request.ServletWebRequest
					org.springframework.web.context.request.async.NoSupportAsyncWebRequest
		addCompletionHandler(Runnable runnable)
		addTimeoutHandler(Runnable runnable)
		dispatch(): Dispatch the request to the container in order to resume processing after concurrent execution in an application thread.
		isAsyncComplete(): 
		isAsyncStarted(): 
		setTimeout(Long timeout): 
		startAsync(): 
****StandardServletAsyncWebRequest: 要在web.xml里面配置参数<async-support>true</async-support>以支持异步操作。猜测是异步操作的基础(不确定)
		org.springframework.web.context.request.AbstractRequestAttributes
			org.springframework.web.context.request.ServletRequestAttributes
				org.springframework.web.context.request.ServletWebRequest
					org.springframework.web.context.request.async.StandardServletAsyncWebRequest
		The servlet and all filters involved in an async request must have async support enabled using the Servlet API or by adding an <async-support>true</async-support> element to servlet and filter declarations in web.xml
		onComplete(AsyncEvent event)
		onError(AsyncEvent event)
		onStartAsync(AsyncEvent event)
		onTimeout(AsyncEvent event)
		......
	TimeoutCallableProcessingInterceptor: 	
		Sends a 503 (SERVICE_UNAVAILABLE) in case of a timeout if the response is not already committed. Registered at the end, after all other interceptors and therefore invoked only if no other interceptor handles the timeout.
		Note that according to RFC 2616, a 503 without a 'Retry-After' header is interpreted as a 500 error and the client should not retry. Applications can install their own interceptor to handle a timeout and add a 'Retry-After' header if necessary.
		handleTimeout(NativeWebRequest request, Callable<T> task): This implementation always returns RESULT_NONE.
	TimeoutDeferredResultProcessingInterceptor: 同上
	WebAsyncManager: 没怎么看懂
		The central class for managing asynchronous request processing, mainly intended as an SPI and not typically used directly by application classes.
		An async scenario starts with request processing as usual in a thread (T1). Concurrent request handling can be initiated by calling startCallableProcessing or startDeferredResultProcessing, both of which produce a result in a separate thread (T2). The result is saved and the request dispatched to the container, to resume processing with the saved result in a third thread (T3). Within the dispatched thread (T3), the saved result can be accessed via getConcurrentResult() or its presence detected via hasConcurrentResult().
	WebAsyncTask<V>: Holder for a Callable, a timeout value, and a task executor. 被上面的WebAsyncManager使用
	WebAsyncManager: Utility methods related to processing asynchronous web requests.
		createAsyncWebRequest(HttpServletRequest request, HttpServletResponse response): Create an AsyncWebRequest instance.
		getAsyncManager(ServletRequest servletRequest): Obtain the WebAsyncManager for the current request, or if not found, create and associate it with the request.
		getAsyncManager(WebRequest webRequest): Obtain the WebAsyncManager for the current request, or if not found, create and associate it with the request.


org.springframework.web.context.support
***	AbstractRefreshableWebApplicationContext:
		继承层次：
		org.springframework.core.io.DefaultResourceLoader
			org.springframework.context.support.AbstractApplicationContext
				org.springframework.context.support.AbstractRefreshableApplicationContext
					org.springframework.context.support.AbstractRefreshableConfigApplicationContext
						org.springframework.web.context.support.AbstractRefreshableWebApplicationContext
		All Implemented Interfaces:
			Closeable, AutoCloseable, Aware, BeanFactory, BeanNameAware, DisposableBean, HierarchicalBeanFactory, InitializingBean, ListableBeanFactory, ApplicationContext, 
			ApplicationEventPublisher, ConfigurableApplicationContext, Lifecycle, MessageSource, EnvironmentCapable, ResourceLoader, ResourcePatternResolver, 
			ThemeSource, ConfigurableWebApplicationContext, WebApplicationContext

		Direct Known Subclasses:
			AnnotationConfigWebApplicationContext, XmlWebApplicationContext 
		createEnvironment()
		getApplicationName()
		getApplicationName()
		getNamespace()
		getResourceByPath(String path)
		getResourcePatternResolver()
		getServletConfig()
		getServletContext()
		getTheme(String themeName)
		initPropertySources()
		onRefresh()
		postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)
		setNamespace(String namespace)
		setServletConfig(ServletConfig servletConfig)
		setServletContext(ServletContext servletContext)
***	AnnotationConfigWebApplicationContext
		java.lang.Object
			org.springframework.core.io.DefaultResourceLoader
				org.springframework.context.support.AbstractApplicationContext
					org.springframework.context.support.AbstractRefreshableApplicationContext
						org.springframework.context.support.AbstractRefreshableConfigApplicationContext
							org.springframework.web.context.support.AbstractRefreshableWebApplicationContext
								org.springframework.web.context.support.AnnotationConfigWebApplicationContext
		WebApplicationContext implementation which accepts annotated classes as input - in particular @Configuration-annotated classes, but also plain @Component classes and JSR-330 compliant classes using javax.inject annotations. Allows for registering classes one by one (specifying class names as config location) as well as for classpath scanning (specifying base packages as config location).
		This is essentially the equivalent of AnnotationConfigApplicationContext for a web environment.
		To make use of this application context, the "contextClass" context-param for ContextLoader and/or "contextClass" init-param for FrameworkServlet must be set to the fully-qualified name of this class.
		As of Spring 3.1, this class may also be directly instantiated and injected into Spring's DispatcherServlet or ContextLoaderListener when using the new WebApplicationInitializer code-based alternative to web.xml. See its Javadoc for details and usage examples.
		Unlike XmlWebApplicationContext, no default configuration class locations are assumed. Rather, it is a requirement to set the "contextConfigLocation" context-param for ContextLoader and/or "contextConfigLocation" init-param for FrameworkServlet. The param-value may contain both fully-qualified class names and base packages to scan for components. 
		See loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory) for exact details on how these locations are processed.
		As an alternative to setting the "contextConfigLocation" parameter, users may implement an ApplicationContextInitializer and set the "contextInitializerClasses" context-param / init-param. In such cases, users should favor the AbstractApplicationContext.refresh() and scan(String...) methods over the setConfigLocation(String) method, which is primarily for use by ContextLoader
		Note: In case of multiple @Configuration classes, later @Bean definitions will override ones defined in earlier loaded files. This can be leveraged to deliberately override certain bean definitions via an extra Configuration class.
		getBeanNameGenerator():
		getScopeMetadataResolver():
		loadBeanDefinitions(DefaultListableBeanFactory beanFactory):
		register(Class<?>... annotatedClasses):
		scan(String... basePackages):
		setBeanNameGenerator(BeanNameGenerator beanNameGenerator) :
		setConfigLocation(String location):
		setConfigLocations(String[] locations):
		setScopeMetadataResolver(ScopeMetadataResolver scopeMetadataResolver)
***	ContextExposingHttpServletRequest: 装饰器类，HttpServletRequest decorator that makes all Spring beans in a given WebApplicationContext accessible as request attributes, through lazy checking once an attribute gets accessed.
		java.lang.Object
			javax.servlet.ServletRequestWrapper
				javax.servlet.http.HttpServletRequestWrapper
					org.springframework.web.context.support.ContextExposingHttpServletRequest
		All Implemented Interfaces:
			HttpServletRequest, ServletRequest 
		getAttribute(String name):
		getWebApplicationContext():
		setAttribute(String name, Object value):
***	GenericWebApplicationContext:	用于编程方式的bean defination取得。If you intend to implement a WebApplicationContext that reads bean definitions from configuration files, consider deriving from AbstractRefreshableWebApplicationContext, reading the bean definitions in an implementation of the loadBeanDefinitions method.
		Interprets resource paths as servlet context resources, i.e. as paths beneath the web application root. Absolute paths, e.g. for files outside the web app root, can be accessed via "file:" URLs, as implemented by AbstractApplicationContext.
		In addition to the special beans detected by AbstractApplicationContext, this class detects a ThemeSource bean in the context, with the name "themeSource".
		java.lang.Object
			org.springframework.core.io.DefaultResourceLoader
				org.springframework.context.support.AbstractApplicationContext
					org.springframework.context.support.GenericApplicationContext
						org.springframework.web.context.support.GenericWebApplicationContext
		All Implemented Interfaces:
			Closeable, AutoCloseable, BeanFactory, DisposableBean, HierarchicalBeanFactory, ListableBeanFactory, BeanDefinitionRegistry, 
			ApplicationContext, ApplicationEventPublisher, ConfigurableApplicationContext, Lifecycle, MessageSource, AliasRegistry, 
			EnvironmentCapable, ResourceLoader, ResourcePatternResolver, ThemeSource, ConfigurableWebApplicationContext, WebApplicationContext 
		createEnvironment()
		getApplicationName()
		getApplicationName()
		getNamespace()
		getResourceByPath(String path)
		getResourcePatternResolver()
		getServletConfig()
		getServletContext()
		getTheme(String themeName)
		initPropertySources()
		onRefresh()
		postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)
		setConfigLocation(String configLocation)
		setConfigLocations(String[] configLocations)
		setNamespace(String namespace)
		setServletConfig(ServletConfig servletConfig)
		setServletContext(ServletContext servletContext)
	HttpRequestHandlerServlet: 	
		Simple HttpServlet that delegates to an HttpRequestHandler bean defined in Spring's root web application context. The target bean name must match the HttpRequestHandlerServlet servlet-name as defined in web.xml.
		This can for example be used to expose a single Spring remote exporter, such as HttpInvokerServiceExporter or HessianServiceExporter, per HttpRequestHandlerServlet definition. 
		This is a minimal alternative to defining remote exporters as beans in a DispatcherServlet context (with advanced mapping and interception facilities being available there).
		init():
		service(HttpServletRequest request, HttpServletResponse response):
	LiveBeansViewServlet: Generates a JSON snapshot for current beans and their dependencies in all ApplicationContexts that live within the current web application.
	RequestHandledEvent: Event raised when a request is handled within an ApplicationContext. 
		Supported by Spring's own FrameworkServlet (through a specific ServletRequestHandledEvent subclass), but can also be raised by any other web component. Used, for example, by Spring's out-of-the-box PerformanceMonitorListener.
		getDescription():
		getDescription():
		getProcessingTimeMillis():
		getSessionId():
		getShortDescription():
		getUserName():
		toString():
		wasFailure():
	ServletConfigPropertySource: PropertySource that reads init parameters from a ServletConfig object.
		getProperty(String name)
		getPropertyNames()
*	ServletContextAttributeExporter: 
		Exporter that takes Spring-defined objects and exposes them as ServletContext attributes. Usually, bean references will be used to export Spring-defined beans as ServletContext attributes.
		Useful to make Spring-defined beans available to code that is not aware of Spring at all, but rather just of the Servlet API. Client code can then use plain ServletContext attribute lookups to access those objects, despite them being defined in a Spring application context.
		Alternatively, consider using the WebApplicationContextUtils class to access Spring-defined beans via the WebApplicationContext interface. 
		This makes client code aware of Spring API, of course.
		setAttributes(Map<String,Object> attributes): Set the ServletContext attributes to expose as key-value pairs.
		setServletContext(ServletContext servletContext)
	ServletContextAttributeFactoryBean:下面这些方法都是从接口中继承来的
		All Implemented Interfaces:
			Aware, FactoryBean<Object>, ServletContextAware 
		FactoryBean that fetches a specific, existing ServletContext attribute. Exposes that ServletContext attribute when used as bean reference, effectively making it available as named Spring bean instance.
		Intended to link in ServletContext attributes that exist before the startup of the Spring application context. Typically, such attributes will have been put there by third-party web frameworks. In a purely Spring-based web application, no such linking in of ServletContext attributes will be necessary. 
		NOTE: As of Spring 3.0, you may also use the "contextAttributes" default bean which is of type Map, and dereference it using an "#{contextAttributes.myKey}" expression to access a specific attribute by name.
		getObject():
		getObjectType():
		isSingleton():
		setAttributeName(String attributeName):
		setServletContext(ServletContext servletContext):
**	ServletContextAwareProcessor implements BeanPostProcessor: 
		BeanPostProcessor implementation that passes the ServletContext to beans that implement the ServletContextAware interface. 
		Web application contexts will automatically register this with their underlying bean factory. Applications do not use this directly.
		postProcessAfterInitialization(Object bean, String beanName):
		postProcessBeforeInitialization(Object bean, String beanName):
	ServletContextFactoryBean: 	Deprecated
	ServletContextLiveBeansView: LiveBeansView subclass which looks for all ApplicationContexts in the web application, as exposed in ServletContext attributes.
		All Implemented Interfaces:
			Aware, ApplicationContextAware, LiveBeansViewMBean 
		findApplicationContexts(): Find all applicable ApplicationContexts for the current application.
*	ServletContextParameterFactoryBean: implements FactoryBean<String>, ServletContextAware	
		FactoryBean that retrieves a specific ServletContext init parameter (that is, a "context-param" defined in web.xml). Exposes that ServletContext init parameter when used as bean reference, effectively making it available as named Spring bean instance.
		NOTE: As of Spring 3.0, you may also use the "contextParameters" default bean which is of type Map, and dereference it using an "#{contextParameters.myKey}" expression to access a specific parameter by name.
	ServletContextPropertyPlaceholderConfigurer: Deprecated
		org.springframework.core.io.support.PropertiesLoaderSupport
			org.springframework.beans.factory.config.PropertyResourceConfigurer
				org.springframework.beans.factory.config.PlaceholderConfigurerSupport
					org.springframework.beans.factory.config.PropertyPlaceholderConfigurer
						org.springframework.web.context.support.ServletContextPropertyPlaceholderConfigurer
	ServletContextPropertySource: PropertySource that reads init parameters from a ServletContext object.
		org.springframework.core.env.PropertySource<T>
			org.springframework.core.env.EnumerablePropertySource<ServletContext>
		getProperty(String name)
		getPropertyNames()
	ServletContextResource: Implemented ContextResource, InputStreamSource, Resource
		org.springframework.core.io.AbstractResource
			org.springframework.core.io.AbstractFileResolvingResource
				org.springframework.web.context.support.ServletContextResource
		Resource implementation for ServletContext resources, interpreting relative paths within the web application root directory.
		Always supports stream access and URL access, but only allows java.io.File access when the web application archive is expanded.
	ServletContextResourceLoader:
		org.springframework.core.io.DefaultResourceLoader
			org.springframework.web.context.support.ServletContextResourceLoader
		ResourceLoader implementation that resolves paths as ServletContext resources, for use outside a WebApplicationContext (for example, in an HttpServletBean or GenericFilterBean subclass).
		Within a WebApplicationContext, resource paths are automatically resolved as ServletContext resources by the context implementation.
		getResourceByPath(String path): This implementation supports file paths beneath the root of the web application.
	ServletContextResourcePatternResolver: Implemented ResourceLoader, ResourcePatternResolver
		ServletContext-aware subclass of PathMatchingResourcePatternResolver, able to find matching resources below the web application root directory via Servlet 2.3's ServletContext.getResourcePaths. Falls back to the superclass' file system checking for other resources.
		doFindPathMatchingFileResources(Resource rootDirResource, String subPattern): Overridden version which checks for ServletContextResource and uses ServletContext.getResourcePaths to find matching resources below the web application root directory.
		doRetrieveMatchingServletContextResources(ServletContext servletContext, String fullPattern, String dir, Set<Resource> result):
			Recursively retrieve ServletContextResources that match the given pattern, adding them to the given result set.
	ServletContextScope:
		Scope wrapper for a ServletContext, i.e. for global web application attributes.
		This differs from traditional Spring singletons in that it exposes attributes in the ServletContext. Those attributes will get destroyed whenever the entire application shuts down, which might be earlier or later than the shutdown of the containing Spring ApplicationContext.
		The associated destruction mechanism relies on a ContextCleanupListener being registered in web.xml. Note that ContextLoaderListener includes ContextCleanupListener's functionality.
		This scope is registered as default scope with key "application".
*	ServletRequestHandledEvent:  Servlet-specific subclass of RequestHandledEvent, adding servlet-specific context information.
		java.util.EventObject
			org.springframework.context.ApplicationEvent
				org.springframework.web.context.support.RequestHandledEvent
					org.springframework.web.context.support.ServletRequestHandledEvent
		getClientAddress()
		getDescription()
		getMethod()
		getRequestUrl()
		getServletName()
		getShortDescription()
		toString()
****SpringBeanAutowiringSupport: 
		Convenient base class for self-autowiring classes that gets constructed within a Spring-based web application. Resolves @Autowired annotations in the endpoint class against beans in the current Spring root web application context (as determined by the current thread's context ClassLoader, which needs to be the web application's ClassLoader). Can alternatively be used as a delegate instead of as a base class.
		A typical usage of this base class is a JAX-WS endpoint class: Such a Spring-based JAX-WS endpoint implementation will follow the standard JAX-WS contract for endpoint classes but will be 'thin' in that it delegates the actual work to one or more Spring-managed service beans - typically obtained using @Autowired. The lifecycle of such an endpoint instance will be managed by the JAX-WS runtime, hence the need for this base class to provide @Autowired processing based on the current Spring context.
		NOTE: If there is an explicit way to access the ServletContext, prefer such a way over using this class. The WebApplicationContextUtils class allows for easy access to the Spring root web application context based on the ServletContext.
		processInjectionBasedOnCurrentContext(Object target):
			Process @Autowired injection for the given target object, based on the current web application context.
		processInjectionBasedOnServletContext(Object target, ServletContext servletContext)
			Process @Autowired injection for the given target object, based on the current root web application context as stored in the ServletContext.
	StandardServletEnvironment:Implemented ConfigurableEnvironment, ConfigurablePropertyResolver, Environment, PropertyResolver, ConfigurableWebEnvironment
		org.springframework.core.env.AbstractEnvironment
			org.springframework.core.env.StandardEnvironment
				org.springframework.web.context.support.StandardServletEnvironment
		JNDI_PROPERTY_SOURCE_NAME: JNDI property source name: "jndiProperties"
		SERVLET_CONFIG_PROPERTY_SOURCE_NAME: Servlet config init parameters property source name: "servletConfigInitParams"
		SERVLET_CONTEXT_PROPERTY_SOURCE_NAME: Servlet context init parameters property source name: "servletContextInitParams"
		customizePropertySources(MutablePropertySources propertySources):
			Customize the set of property sources with those contributed by superclasses as well as those appropriate for standard servlet-based environments: "servletConfigInitParams" "servletContextInitParams" "jndiProperties" 
		initPropertySources(ServletContext servletContext, ServletConfig servletConfig): Replace any stub property source instances acting as placeholders with real servlet context/config property sources using the given parameters.
***	StaticWebApplicationContext: 仅用于测试，不能用在产品中！！！ Static WebApplicationContext implementation for testing. Not intended for use in production applications. 
		org.springframework.core.io.DefaultResourceLoader
			org.springframework.context.support.AbstractApplicationContext
				org.springframework.context.support.GenericApplicationContext
					org.springframework.context.support.StaticApplicationContext
						org.springframework.web.context.support.StaticWebApplicationContext
		All Implemented Interfaces:
			Closeable, AutoCloseable, BeanFactory, DisposableBean, HierarchicalBeanFactory, ListableBeanFactory, BeanDefinitionRegistry, 
			ApplicationContext, ApplicationEventPublisher, ConfigurableApplicationContext, Lifecycle, MessageSource, AliasRegistry, 
			EnvironmentCapable, ResourceLoader, ResourcePatternResolver, ThemeSource, ConfigurableWebApplicationContext, WebApplicationContext 
***	WebApplicationContextUtils: 比较有用
		Convenience methods for retrieving the root WebApplicationContext for a given ServletContext. This is e.g. useful for accessing a Spring context from within custom web views or Struts actions.
		Note that there are more convenient ways of accessing the root context for many web frameworks, either part of Spring or available as external library. This helper class is just the most generic way to access the root context.
		getRequiredWebApplicationContext(ServletContext sc):
			Find the root WebApplicationContext for this web application, which is typically loaded via ContextLoaderListener.
		getWebApplicationContext(ServletContext sc)
			Find the root WebApplicationContext for this web application, which is typically loaded via ContextLoaderListener.
		getWebApplicationContext(ServletContext sc, String attrName)
			Find a custom WebApplicationContext for this web application.
		initServletPropertySources(MutablePropertySources propertySources, ServletContext servletContext)
			Convenient variant of initServletPropertySources(MutablePropertySources, ServletContext, ServletConfig) that always provides null for the ServletConfig parameter.
		initServletPropertySources(MutablePropertySources propertySources, ServletContext servletContext, ServletConfig servletConfig)
			Replace Servlet-based stub property sources with actual instances populated with the given servletContext and servletConfig objects.
		registerEnvironmentBeans(ConfigurableListableBeanFactory bf, ServletContext sc)
			Register web-specific environment beans ("contextParameters", "contextAttributes") with the given BeanFactory, as used by the WebApplicationContext.
		registerEnvironmentBeans(ConfigurableListableBeanFactory bf, ServletContext sc, ServletConfig config)
			Register web-specific environment beans ("contextParameters", "contextAttributes") with the given BeanFactory, as used by the WebApplicationContext.
		registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory)
			Register web-specific scopes ("request", "session", "globalSession") with the given BeanFactory, as used by the WebApplicationContext.
		registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory, ServletContext sc)
			Register web-specific scopes ("request", "session", "globalSession", "application") with the given BeanFactory, as used by the WebApplicationContext.	
**	abstract class WebApplicationObjectSupport: Convenient superclass for application objects running in a WebApplicationContext. Provides getWebApplicationContext(), getServletContext(), and getTempDir() methods.
		org.springframework.context.support.ApplicationObjectSupport
			org.springframework.web.context.support.WebApplicationObjectSupport
		All Implemented Interfaces:
			Aware, ApplicationContextAware, ServletContextAware
		Direct Known Subclasses:
			AbstractCachingViewResolver, AbstractHandlerMapping, AbstractView, BeanNameViewResolver, 
			ContentNegotiatingViewResolver, TilesConfigurer, WebContentGenerator 
		getServletContext()
*		getTempDir(): Return the temporary directory for the current web application, as provided by the servlet container.
		getWebApplicationContext(): 
		initApplicationContext(ApplicationContext context): 
		initServletContext(ServletContext servletContext):  Subclasses may override this for custom initialization based on the ServletContext that this application object runs in. 
		isContextRequired(): 
		setServletContext(ServletContext servletContext): 
****XmlWebApplicationContext: web系统启动的基础类，这个类的继承层次的每个接口可以好好看看，功能分布的挺散。非常重要!!!
		org.springframework.core.io.DefaultResourceLoader
			org.springframework.context.support.AbstractApplicationContext
				org.springframework.context.support.AbstractRefreshableApplicationContext
					org.springframework.context.support.AbstractRefreshableConfigApplicationContext
						org.springframework.web.context.support.AbstractRefreshableWebApplicationContext
							org.springframework.web.context.support.XmlWebApplicationContext
		All Implemented Interfaces:
			Closeable, AutoCloseable, Aware, BeanFactory, BeanNameAware, DisposableBean, HierarchicalBeanFactory, 
			InitializingBean, ListableBeanFactory, ApplicationContext, ApplicationEventPublisher, 
			ConfigurableApplicationContext, Lifecycle, MessageSource, EnvironmentCapable, ResourceLoader, 
			ResourcePatternResolver, ThemeSource, ConfigurableWebApplicationContext, WebApplicationContext
org.springframework.web.filter
	AbstractRequestLoggingFilter: 可用于log记录
		org.springframework.web.filter.GenericFilterBean
			org.springframework.web.filter.OncePerRequestFilter
				org.springframework.web.filter.AbstractRequestLoggingFilter
		Direct Known Subclasses:
			CommonsRequestLoggingFilter, Log4jNestedDiagnosticContextFilter, ServletContextRequestLoggingFilter 
	CharacterEncodingFilter: encoding设置
	CommonsRequestLoggingFilter: Simple request logging filter that writes the request URI (and optionally the query string) to the Commons Log.
	CompositeFilter: A generic composite servlet Filter that just delegates its behaviour to a chain (list) of user supplied filters, 
		achieving the functionality of a FilterChain, but conveniently using only Filter instances. 
		This is useful for filters that require dependency injection, and can therefore be set up in a Spring application context. 
		Typically this composite would be used in conjunction with DelegatingFilterProxy, so that it can be declared in Spring but applied to a servlet context.
	DelegatingFilterProxy: 	
		Proxy for a standard Servlet 2.3 Filter, delegating to a Spring-managed bean that implements the Filter interface. Supports a "targetBeanName" filter init-param in web.xml, specifying the name of the target bean in the Spring application context.
		web.xml will usually contain a DelegatingFilterProxy definition, with the specified filter-name corresponding to a bean name in Spring's root application context. All calls to the filter proxy will then be delegated to that bean in the Spring context, which is required to implement the standard Servlet 2.3 Filter interface.
		This approach is particularly useful for Filter implementation with complex setup needs, allowing to apply the full Spring bean definition machinery to Filter instances. Alternatively, consider standard Filter setup in combination with looking up service beans from the Spring root application context.
		NOTE: The lifecycle methods defined by the Servlet Filter interface will by default not be delegated to the target bean, relying on the Spring application context to manage the lifecycle of that bean. Specifying the "targetFilterLifecycle" filter init-param as "true" will enforce invocation of the Filter.init and Filter.destroy lifecycle methods on the target bean, letting the servlet container manage the filter lifecycle.
		As of Spring 3.1, DelegatingFilterProxy has been updated to optionally accept constructor parameters when using Servlet 3.0's instance-based filter registration methods, usually in conjunction with Spring 3.1's WebApplicationInitializer SPI. These constructors allow for providing the delegate Filter bean directly, or providing the application context and bean name to fetch, avoiding the need to look up the application context from the ServletContext.
		This class was originally inspired by Spring Security's FilterToBeanProxy class, written by Ben Alex.
	GenericFilterBean: Simple base implementation of Filter which treats its config parameters (init-param entries within the filter tag in web.xml) as bean properties. 
		All Implemented Interfaces:
			Filter, Aware, BeanNameAware, DisposableBean, InitializingBean, EnvironmentAware, ServletContextAware
		Direct Known Subclasses:
			DelegatingFilterProxy, OncePerRequestFilter 	
		A handy superclass for any type of filter. Type conversion of config parameters is automatic, with the corresponding setter method getting invoked with the converted value. 
		It is also possible for subclasses to specify required properties. Parameters without matching bean property setter will simply be ignored.
		This filter leaves actual filtering to subclasses, which have to implement the Filter.doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain) method.
		This generic filter base class has no dependency on the Spring ApplicationContext concept. 
		Filters usually don't load their own context but rather access service beans from the Spring root application context, 
		accessible via the filter's ServletContext (see WebApplicationContextUtils).
	HiddenHttpMethodFilter: 
		org.springframework.web.filter.GenericFilterBean
			org.springframework.web.filter.OncePerRequestFilter
				org.springframework.web.filter.HiddenHttpMethodFilter
		All Implemented Interfaces:
			Filter, Aware, BeanNameAware, DisposableBean, InitializingBean, EnvironmentAware, ServletContextAware 
		Filter that converts posted method parameters into HTTP methods, retrievable via HttpServletRequest.getMethod(). 
		Since browsers currently only support GET and POST, a common technique - used by the Prototype library, 
		for instance - is to use a normal POST with an additional hidden form field (_method) to pass the "real" HTTP method along. 
		This filter reads that parameter and changes the HttpServletRequestWrapper.getMethod() return value accordingly.
		The name of the request parameter defaults to _method, but can be adapted via the methodParam property.
		NOTE: This filter needs to run after multipart processing in case of a multipart POST request, due to its inherent need for checking a POST body parameter. 
		So typically, put a Spring MultipartFilter before this HiddenHttpMethodFilter in your web.xml filter chain.




	
HtmlUtils
JavaScriptUtils
UriComponents.encode()
UriComponentsBuilder
	UriTemplate template = new UriTemplate("http://example.com/hotels/{hotel}/bookings/{booking}");
	System.out.println(template.match("http://example.com/hotels/1/bookings/42"));
UrlPathHelper：得到uri的部分内容，比较有用
WebUtils：比较有用